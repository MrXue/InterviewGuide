(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{454:function(t,_,v){"use strict";v.r(_);var e=v(62),s=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{align:"center"}},[t._v("计算机网络")]),t._v(" "),v("p",{attrs:{id:"偶爱死的七层模型分别是各自的功能是什么"}}),t._v(" "),v("div",{staticStyle:{"border-color":"#24C6DC","background-color":"#e9f9f3",margin:"1rem 0",padding:".25rem 1rem","border-left-width":".3rem","border-left-style":"solid","border-radius":".5rem",color:"inherit"}},[v("p",[t._v("这是六则或许对你有些许帮助的信息:")]),t._v(" "),v("p",[t._v("⭐️1、阿秀与朋友合作开发了一个"),v("span",{staticStyle:{"font-weight":"bold",color:"red"}},[t._v("编程资源网站")]),t._v("，目前已经收录了很多不错的学习资源和黑科技（附带下载地址），如过你想要寻求合适的编程资源，"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://tools.interviewguide.cn/home",target:"_blank"}},[t._v("欢迎体验")]),t._v("以及推荐自己认为不错的资源，众人拾柴火焰高，我为人人，人人为我🔥！")]),t._v(" "),v("p",[t._v("2、👉23年5月份阿秀从"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzk0ODU4MzEzMw==&mid=2247512170&idx=1&sn=c4a04a383d2dfdece676b75f17224e78",target:"_blank"}},[t._v("字节跳动离职跳槽到某外企")]),t._v("期间，为"),v("span",{staticStyle:{"font-weight":"bold"}},[t._v("方便自己找工作，增加上岸几率")]),t._v("，我自己从0开发了一个"),v("span",{staticStyle:{"font-weight":"bold",color:"red"}},[t._v("互联网中大厂面试真题解析网站")]),t._v("，包括两个前端和一个后端。能够定向查看某些公司的某些岗位面试真题，比如我想查一下行业为互联网，公司为字节跳动，考察岗位为后端，考察时间为最近一年之类的面试题有哪些？\n")]),v("div",{attrs:{align:"center"}}),t._v("网站地址："),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://top.interviewguide.cn/",target:"_blank"}},[t._v("InterviewGuide大厂面试真题解析网站")]),t._v("。点此可以查看该网站的视频介绍："),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://www.bilibili.com/video/BV1f94y1C7BL",target:"_blank"}},[t._v("B站视频讲解")]),t._v("   如果可以的话求个B站三连，感谢！\n  "),v("p"),t._v("3、😊\n    分享一个学弟发给我的"),v("span",{staticStyle:{"font-weight":"bold",color:"red"}},[t._v("20T网盘资源合集")]),t._v("，"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://docs.qq.com/sheet/DY3VPVklVaFFMcUZ4?tab=9h5afr",target:"_blank"}},[t._v("点此白嫖")]),t._v("，主要是各类高清影视、电视剧、音乐、副业、纪录片、英语四六级考试、考研考公等资源。\n  "),v("p"),t._v(" "),v("p",[t._v("4、😍免费分享阿秀个人学习计算机以来收集到的免费学习资源，"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"/notes/07-resources/01-free/01-introduce.html",target:"_blank"}},[t._v("点此白嫖")]),t._v("；也记录一下自己以前买过的"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"/notes/07-resources/02-precious.html",target:"_blank"}},[t._v("不错的计算机书籍、网络专栏和垃圾付费专栏")]),t._v("；也记录一下自己以前买过的"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"/notes/07-resources/02-precious.html",target:"_blank"}},[t._v("不错的计算机书籍、网络专栏和垃圾付费专栏")])]),t._v(" "),v("p",[t._v("5、🚀如果你想在校招中顺利拿到更好的offer，阿秀建议你多看看前人"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://www.yuque.com/tuobaaxiu/httmmc/npg1k81zeq4wfpyz",target:"_blank"}},[t._v("踩过的坑")]),t._v("和"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{target:"_blank",href:"https://www.yuque.com/tuobaaxiu/httmmc/gge9ppd0mbu2d3dp"}},[t._v("留下的经验")]),t._v("，事实上你现在遇到的大多数问题你的学长学姐师兄师姐基本都已经遇到过了。\n  ")]),t._v(" "),v("p",[t._v("6、🔥 欢迎准备计算机校招的小伙伴加入我的"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://www.yuque.com/tuobaaxiu/httmmc/xg0otqvc17wfx4u9",target:"_blank"}},[t._v("学习圈子")]),t._v("，一个人踽踽独行不如一群人报团取暖，圈子里沉淀了很多过去21/22/23届学长学姐的"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://www.yuque.com/tuobaaxiu/httmmc/gge9ppd0mbu2d3dp",target:"_blank"}},[t._v("经验和总结")]),t._v("，好好跟着走下去的，最后基本都可以拿到不错的offer！此外，每周都会进行"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://www.yuque.com/tuobaaxiu/httmmc/npg1k81zeq4wfpyz",target:"_blank"}},[t._v("精华总结和分享！")]),t._v("如果你需要《阿秀的学习笔记》网站中📚︎校招八股文相关知识点的PDF版本的话，可以"),v("a",{staticStyle:{"text-decoration":"underline"},attrs:{href:"https://www.yuque.com/tuobaaxiu/httmmc/qs0yn66apvkzw0ps",target:"_blank"}},[t._v("点此下载")]),t._v(" 。")])]),t._v(" "),v("p",{attrs:{id:"使用赛森的过程是怎样的"}}),t._v(" "),v("h2",{attrs:{id:"_41、使用-session-的过程是怎样的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_41、使用-session-的过程是怎样的"}},[t._v("#")]),t._v(" 41、使用 Session 的过程是怎样的？")]),t._v(" "),v("p",[t._v("过程如下：")]),t._v(" "),v("ul",[v("li",[t._v("用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；")]),t._v(" "),v("li",[t._v("服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；")]),t._v(" "),v("li",[t._v("服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；")]),t._v(" "),v("li",[t._v("客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。")])]),t._v(" "),v("p",[v("strong",[t._v("注意")]),t._v("：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。")]),t._v(" "),v("p",{attrs:{id:"赛森和库克应该如何去选择适用场景"}}),t._v(" "),v("h2",{attrs:{id:"_42、session和cookie应该如何去选择-适用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_42、session和cookie应该如何去选择-适用场景"}},[t._v("#")]),t._v(" 42、Session和cookie应该如何去选择（适用场景）？")]),t._v(" "),v("ul",[v("li",[t._v("Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；")]),t._v(" "),v("li",[t._v("Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；")]),t._v(" "),v("li",[t._v("对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。")])]),t._v(" "),v("p",{attrs:{id:"库克和赛森区别是什么"}}),t._v(" "),v("h2",{attrs:{id:"_43、cookies和session区别是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_43、cookies和session区别是什么"}},[t._v("#")]),t._v(" 43、Cookies和Session区别是什么？")]),t._v(" "),v("p",[t._v("Cookie和Session都是客户端与服务器之间保持状态的解决方案\n1，存储的位置不同，cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全\n2，存储的数据类型不同\n两者都是key-value的结构，但针对value的类型是有差异的\ncookie：value只能是字符串类型，session：value是Object类型\n3，存储的数据大小限制不同\ncookie：大小受浏览器的限制，很多是是4K的大小， session：理论上受当前内存的限制，\n4，生命周期的控制\ncookie的生命周期当浏览器关闭的时候，就消亡了\n(1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束，\n(2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁")]),t._v(" "),v("p",{attrs:{id:"都懂攻击了解吗"}}),t._v(" "),v("h2",{attrs:{id:"_44、ddos-攻击了解吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_44、ddos-攻击了解吗"}},[t._v("#")]),t._v(" 44、DDos 攻击了解吗？")]),t._v(" "),v("p",[t._v("客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认\n没有彻底根治的办法，除非不使用TCP\nDDos 预防：\n1）限制同时打开SYN半链接的数目\n2）缩短SYN半链接的Time out 时间\n3）关闭不必要的服务")]),t._v(" "),v("p",{attrs:{id:"哀木梯有和爱慕斯分别是什么"}}),t._v(" "),v("h2",{attrs:{id:"_45、mtu和mss分别是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_45、mtu和mss分别是什么"}},[t._v("#")]),t._v(" 45、MTU和MSS分别是什么？")]),t._v(" "),v("p",[t._v("MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。")]),t._v(" "),v("p",[t._v("MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。")]),t._v(" "),v("p",{attrs:{id:"中有个缓存机制但如何保证缓存是最新的呢缓存过期机制"}}),t._v(" "),v("h2",{attrs:{id:"_46、http中有个缓存机制-但如何保证缓存是最新的呢-缓存过期机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_46、http中有个缓存机制-但如何保证缓存是最新的呢-缓存过期机制"}},[t._v("#")]),t._v(" 46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）")]),t._v(" "),v("p",[t._v("max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。")]),t._v(" "),v("p",[t._v("max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。")]),t._v(" "),v("div",{staticClass:"language-html extra-class"},[v("pre",{pre:!0,attrs:{class:"language-html"}},[v("code",[t._v("Cache-Control: max-age=31536000\n")])])]),v("p",[t._v("Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。")]),t._v(" "),v("div",{staticClass:"language-html extra-class"},[v("pre",{pre:!0,attrs:{class:"language-html"}},[v("code",[t._v("Expires: Wed, 04 Jul 2012 08:26:05 GMT\n")])])]),v("ul",[v("li",[t._v("在 HTTP/1.1 中，会优先处理 max-age 指令；")]),t._v(" "),v("li",[t._v("在 HTTP/1.0 中，max-age 指令会被忽略掉。")])]),t._v(" "),v("p",{attrs:{id:"头部中有哪些信息"}}),t._v(" "),v("h2",{attrs:{id:"_47、tcp头部中有哪些信息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_47、tcp头部中有哪些信息"}},[t._v("#")]),t._v(" 47、TCP头部中有哪些信息？")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。")])]),t._v(" "),v("li",[v("p",[t._v("确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。")])]),t._v(" "),v("li",[v("p",[t._v("首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。")])]),t._v(" "),v("li",[v("p",[t._v("标志位（6bit）：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("URG：标志紧急指针是否有效。")])]),t._v(" "),v("li",[v("p",[t._v("ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。")])]),t._v(" "),v("li",[v("p",[t._v("PSH：提示接收端立即从缓冲读走数据。")])]),t._v(" "),v("li",[v("p",[t._v("RST：表示要求对方重新建立连接（复位报文段）。")])]),t._v(" "),v("li",[v("p",[t._v("SYN：表示请求建立一个连接（连接报文段）。")])]),t._v(" "),v("li",[v("p",[t._v("FIN：表示关闭连接（断开报文段）。")])])])]),t._v(" "),v("li",[v("p",[t._v("窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。")])]),t._v(" "),v("li",[v("p",[t._v("校验和（16bit）：接收端用CRC检验整个报文段有无损坏。")])])]),t._v(" "),v("p",{attrs:{id:"常见的连接状态有哪些"}}),t._v(" "),v("h2",{attrs:{id:"_48、常见tcp的连接状态有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_48、常见tcp的连接状态有哪些"}},[t._v("#")]),t._v(" 48、常见TCP的连接状态有哪些？")]),t._v(" "),v("ul",[v("li",[t._v("CLOSED：初始状态。")]),t._v(" "),v("li",[t._v("LISTEN：服务器处于监听状态。")]),t._v(" "),v("li",[t._v("SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。")]),t._v(" "),v("li",[t._v("SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。")]),t._v(" "),v("li",[t._v("ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。")]),t._v(" "),v("li",[t._v("FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。")]),t._v(" "),v("li",[t._v("CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。")]),t._v(" "),v("li",[t._v("FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。")]),t._v(" "),v("li",[t._v("LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。")]),t._v(" "),v("li",[t._v("TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。")])]),t._v(" "),v("p",{attrs:{id:"网络的七层五层模型主要的协议有哪些"}}),t._v(" "),v("h2",{attrs:{id:"_49、网络的七层-五层模型主要的协议有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_49、网络的七层-五层模型主要的协议有哪些"}},[t._v("#")]),t._v(" 49、网络的七层/五层模型主要的协议有哪些？")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://oss.interviewguide.cn/img/202205072300758.png",alt:""}})]),t._v(" "),v("p",{attrs:{id:"特斯皮是什么"}}),t._v(" "),v("h2",{attrs:{id:"_50、tcp是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_50、tcp是什么"}},[t._v("#")]),t._v(" 50、TCP是什么？")]),t._v(" "),v("p",[t._v("TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。")]),t._v(" "),v("p",{attrs:{id:"特斯皮头部报文字段介绍几个各自的功能"}}),t._v(" "),v("h2",{attrs:{id:"_51、tcp头部报文字段介绍几个-各自的功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_51、tcp头部报文字段介绍几个-各自的功能"}},[t._v("#")]),t._v(" 51、TCP头部报文字段介绍几个？各自的功能？")]),t._v(" "),v("p",[t._v("source port 和 destination port")]),t._v(" "),v("blockquote",[v("p",[t._v("两者分别为「源端口号」和「目的端口号」。源端口号就是指本地端口，目的端口就是远程端口。")])]),t._v(" "),v("p",[t._v("可以这么理解，我们有很多软件，每个软件都对应一个端口，假如，你想和我数据交互，咱们得互相知道你我的端口号。")]),t._v(" "),v("p",[t._v("再来一个很官方的：")]),t._v(" "),v("blockquote",[v("p",[t._v("扩展：应用程序的端口号和应用程序所在主机的 IP 地址统称为 socket（套接字），IP:端口号, 在互联网上 socket 唯一标识每一个应用程序，源端口+源IP+目的端口+目的IP称为”套接字对“，一对套接字就是一个连接，一个客户端与服务器之间的连接。")])]),t._v(" "),v("p",[t._v("Sequence Number")]),t._v(" "),v("blockquote",[v("p",[t._v("称为「序列号」。用于 TCP 通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信的有序性，避免网络中乱序的问题。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。初始序列号由自己定，而后绪的序列号由对端的 ACK 决定：SN_x = ACK_y (x 的序列号 = y 发给 x 的 ACK)。")])]),t._v(" "),v("p",[t._v("说白了，类似于身份证一样，而且还得发送此时此刻的所在的位置，就相当于身份证上的地址一样。")]),t._v(" "),v("p",[t._v("Acknowledge Number")]),t._v(" "),v("blockquote",[v("p",[t._v("称为「确认序列号」。确认序列号是接收确认端所期望收到的下一序列号。确认序号应当是上次已成功收到数据字节序号加1，只有当标志位中的 ACK 标志为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题。")])]),t._v(" "),v("p",[t._v("TCP Flag")]),t._v(" "),v("p",[v("code",[t._v("TCP")]),t._v(" 首部中有 6 个标志比特，它们中的多个可同时被设置为 "),v("code",[t._v("1")]),t._v("，主要是用于操控 "),v("code",[t._v("TCP")]),t._v(" 的状态机的，依次为"),v("code",[t._v("URG，ACK，PSH，RST，SYN，FIN")]),t._v("。")]),t._v(" "),v("p",[t._v("当然只介绍三个：")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("ACK")]),t._v("：这个标识可以理解为发送端发送数据到接收端，发送的时候 ACK 为 0，标识接收端还未应答，一旦接收端接收数据之后，就将 ACK 置为 1，发送端接收到之后，就知道了接收端已经接收了数据。")]),t._v(" "),v("li",[v("strong",[t._v("SYN")]),t._v("：表示「同步序列号」，是 TCP 握手的发送的第一个数据包。用来建立 TCP 的连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN=1，ACK=0连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口。")]),t._v(" "),v("li",[v("strong",[t._v("FIN")]),t._v("：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。发送端只剩最后的一段数据了，同时要告诉接收端后边没有数据可以接受了，所以用FIN标识一下，接收端看到这个FIN之后，哦！这是接受的最后的数据，接受完就关闭了；"),v("strong",[t._v("TCP四次分手必然问")]),t._v("。")])]),t._v(" "),v("p",[t._v("Window size")]),t._v(" "),v("blockquote",[v("p",[t._v("称为滑动窗口大小。所说的滑动窗口，用来进行流量控制。")])]),t._v(" "),v("p",{attrs:{id:"偶斯哎的七层模型的主要功能"}}),t._v(" "),v("h2",{attrs:{id:"_52、osi-的七层模型的主要功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_52、osi-的七层模型的主要功能"}},[t._v("#")]),t._v(" 52、OSI 的七层模型的主要功能？")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://oss.interviewguide.cn/img/202205072300329.png",alt:""}})]),t._v(" "),v("p",[t._v("**物理层：**利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。\n**数据链路层：**接收来自物理层的位流形式的数据，并封装成帧，传送到上一层\n**网络层：**将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。\n**传输层：**在源端与目的端之间提供可靠的透明数据传输\n**会话层：**负责在网络中的两节点之间建立、维持和终止通信\n**表示层：**处理用户信息的表示问题，数据的编码，压缩和解压缩，数据的加密和解密\n**应用层：**为用户的应用进程提供网络通信服务")]),t._v(" "),v("p",{attrs:{id:"应用层常见协议知道多少了解几个"}}),t._v(" "),v("h2",{attrs:{id:"_53、应用层常见协议知道多少-了解几个"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_53、应用层常见协议知道多少-了解几个"}},[t._v("#")]),t._v(" 53、应用层常见协议知道多少？了解几个？")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("协议")]),t._v(" "),v("th",[t._v("名称")]),t._v(" "),v("th",[t._v("默认端口")]),t._v(" "),v("th",[t._v("底层协议")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("HTTP")]),t._v(" "),v("td",[t._v("超文本传输协议")]),t._v(" "),v("td",[t._v("80")]),t._v(" "),v("td",[t._v("TCP")])]),t._v(" "),v("tr",[v("td",[t._v("HTTPS")]),t._v(" "),v("td",[t._v("超文本传输安全协议")]),t._v(" "),v("td",[t._v("443")]),t._v(" "),v("td",[t._v("TCP")])]),t._v(" "),v("tr",[v("td",[t._v("Telnet")]),t._v(" "),v("td",[t._v("远程登录服务的标准协议")]),t._v(" "),v("td",[t._v("23")]),t._v(" "),v("td",[t._v("TCP")])]),t._v(" "),v("tr",[v("td",[t._v("FTP")]),t._v(" "),v("td",[t._v("文件传输协议")]),t._v(" "),v("td",[t._v("20传输和21连接")]),t._v(" "),v("td",[t._v("TCP")])]),t._v(" "),v("tr",[v("td",[t._v("TFTP")]),t._v(" "),v("td",[t._v("简单文件传输协议")]),t._v(" "),v("td",[t._v("69")]),t._v(" "),v("td",[t._v("UDP")])]),t._v(" "),v("tr",[v("td",[t._v("SMTP")]),t._v(" "),v("td",[t._v("简单邮件传输协议（发送用）")]),t._v(" "),v("td",[t._v("25")]),t._v(" "),v("td",[t._v("TCP")])]),t._v(" "),v("tr",[v("td",[t._v("POP")]),t._v(" "),v("td",[t._v("邮局协议（接收用）")]),t._v(" "),v("td",[t._v("110")]),t._v(" "),v("td",[t._v("TCP")])]),t._v(" "),v("tr",[v("td",[t._v("DNS")]),t._v(" "),v("td",[t._v("域名解析服务")]),t._v(" "),v("td",[t._v("53")]),t._v(" "),v("td",[t._v("服务器间进行域传输的时候用TCP"),v("br"),t._v("客户端查询DNS服务器时用 UDP")])])])]),t._v(" "),v("blockquote",[v("p",[t._v("感谢网友勘误”TFTP简单文件传输协议 初始默认端口号69“，已修正，2021.10.12"),v("a",{attrs:{href:"https://github.com/forthespada/InterviewGuide/issues/13",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/forthespada/InterviewGuide/issues/13"),v("OutboundLink")],1)])]),t._v(" "),v("p",{attrs:{id:"浏览器在与服务器建立了一个连接后是否会在一个请求完成后断开什么情况下会断开"}}),t._v(" "),v("h2",{attrs:{id:"_54、浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开-什么情况下会断开"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_54、浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开-什么情况下会断开"}},[t._v("#")]),t._v(" 54、浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？")]),t._v(" "),v("p",[t._v("在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，"),v("strong",[t._v("某些服务器对 Connection: keep-alive 的 Header 进行了支持")]),t._v("。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。")]),t._v(" "),v("p",[v("strong",[t._v("持久连接")]),t._v("：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。")]),t._v(" "),v("p",[t._v("默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。")]),t._v(" "),v("p",{attrs:{id:"三次握手相关内容"}}),t._v(" "),v("h2",{attrs:{id:"_55、三次握手相关内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_55、三次握手相关内容"}},[t._v("#")]),t._v(" 55、三次握手相关内容")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://oss.interviewguide.cn/img/202205072301822.png",alt:""}})]),t._v(" "),v("p",[t._v("三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换"),v("code",[t._v("TCP窗口大小")]),t._v("信息。")]),t._v(" "),v("h3",{attrs:{id:"第一种回答"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一种回答"}},[t._v("#")]),t._v(" 第一种回答")]),t._v(" "),v("p",[t._v("刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 "),v("code",[t._v("SYN_SEND")]),t._v(" 状态。")]),t._v(" "),v("p",[t._v("首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。")])]),t._v(" "),v("li",[v("p",[t._v("第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 "),v("code",[t._v("SYN_RCVD")]),t._v(" 的状态。")]),t._v(" "),v("p",[t._v("在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。")])]),t._v(" "),v("li",[v("p",[t._v("第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 "),v("code",[t._v("ESTABLISHED")]),t._v(" 状态。服务器收到 ACK 报文之后，也处于 "),v("code",[t._v("ESTABLISHED")]),t._v(" 状态，此时，双方已建立起了连接。")]),t._v(" "),v("p",[t._v("确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。")])])]),t._v(" "),v("p",[t._v("发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。")]),t._v(" "),v("p",[t._v("在socket编程中，客户端执行connect()时，将触发三次握手。")]),t._v(" "),v("h3",{attrs:{id:"第二种回答"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二种回答"}},[t._v("#")]),t._v(" 第二种回答")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("初始状态")]),t._v("：客户端处于 "),v("code",[t._v("closed(关闭)")]),t._v("状态，服务器处于 "),v("code",[t._v("listen(监听)")]),t._v(" 状态。")]),t._v(" "),v("li",[v("strong",[t._v("第一次握手")]),t._v("：客户端发送请求报文将 "),v("code",[t._v("SYN = 1")]),t._v("同步序列号和初始化序列号"),v("code",[t._v("seq = x")]),t._v("发送给服务端，发送完之后客户端处于"),v("code",[t._v("SYN_Send")]),t._v("状态。（验证了客户端的发送能力和服务端的接收能力）")]),t._v(" "),v("li",[v("strong",[t._v("第二次握手")]),t._v("：服务端受到 "),v("code",[t._v("SYN")]),t._v(" 请求报文之后，如果同意连接，会以自己的同步序列号"),v("code",[t._v("SYN(服务端) = 1")]),t._v("、初始化序列号 "),v("code",[t._v("seq = y")]),t._v("和确认序列号（期望下次收到的数据包）"),v("code",[t._v("ack = x+ 1")]),t._v(" 以及确认号"),v("code",[t._v("ACK = 1")]),t._v("报文作为应答，服务器为"),v("code",[t._v("SYN_Receive")]),t._v("状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）")]),t._v(" "),v("li",[v("strong",[t._v("第三次握手")]),t._v("： 客户端接收到服务端的 "),v("code",[t._v("SYN + ACK")]),t._v("之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 "),v("code",[t._v("ack = y + 1")]),t._v("和数据包的序列号 "),v("code",[t._v("seq = x + 1")]),t._v("以及确认号"),v("code",[t._v("ACK = 1")]),t._v("确认包作为应答，客户端转为"),v("code",[t._v("established")]),t._v("状态。（分别站在双方的角度上思考，各自ok）")])]),t._v(" "),v("p",{attrs:{id:"为什么需要三次握手两次不行吗"}}),t._v(" "),v("h2",{attrs:{id:"_56、为什么需要三次握手-两次不行吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_56、为什么需要三次握手-两次不行吗"}},[t._v("#")]),t._v(" 56、为什么需要三次握手，两次不行吗？")]),t._v(" "),v("p",[t._v("弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。")]),t._v(" "),v("ul",[v("li",[t._v("第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。")]),t._v(" "),v("li",[t._v("第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。")]),t._v(" "),v("li",[t._v("第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。")])]),t._v(" "),v("p",[t._v("因此，需要三次握手才能确认双方的接收与发送能力是否正常。")]),t._v(" "),v("p",[t._v("试想如果是用两次握手，则会出现下面这种情况：")]),t._v(" "),v("blockquote",[v("p",[t._v("如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在"),v("strong",[t._v("某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端")]),t._v("，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。")])]),t._v(" "),v("p",{attrs:{id:"什么是半连接队列"}}),t._v(" "),v("h2",{attrs:{id:"_57、什么是半连接队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_57、什么是半连接队列"}},[t._v("#")]),t._v(" 57、什么是半连接队列？")]),t._v(" "),v("p",[t._v("服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个"),v("strong",[t._v("队列")]),t._v("里，我们把这种队列称之为"),v("strong",[t._v("半连接队列")]),t._v("。")]),t._v(" "),v("p",[t._v("当然还有一个"),v("strong",[t._v("全连接队列")]),t._v("，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。")]),t._v(" "),v("p",[t._v("这里在补充一点关于"),v("strong",[t._v("SYN-ACK 重传次数")]),t._v("的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......")]),t._v(" "),v("p",{attrs:{id:"爱死南玻是固定的吗"}}),t._v(" "),v("h2",{attrs:{id:"_58、-isn-initial-sequence-number-是固定的吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_58、-isn-initial-sequence-number-是固定的吗"}},[t._v("#")]),t._v(" 58、 ISN(Initial Sequence Number)是固定的吗？")]),t._v(" "),v("p",[t._v("当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN，ISN是一个有可以看作是一个32比特的计数器，但并不是简单的计数器，大概每4ms加1 。")]),t._v(" "),v("blockquote",[v("p",[t._v("ISN = M + F(localhost, localport, remotehost, remoteport)(M为计数器)，ISN应该由这个公式确定，F为哈希算法，不是一个简单计数器。")])]),t._v(" "),v("p",[t._v("这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。")]),t._v(" "),v("p",[v("strong",[t._v("三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。")])]),t._v(" "),v("blockquote",[v("p",[t._v("感谢网友勘误https://github.com/forthespada/InterviewGuide/issues/25 - 2022.02.22")])]),t._v(" "),v("p",{attrs:{id:"三次握手过程中可以携带数据吗"}}),t._v(" "),v("h2",{attrs:{id:"_59、-三次握手过程中可以携带数据吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_59、-三次握手过程中可以携带数据吗"}},[t._v("#")]),t._v(" 59、 三次握手过程中可以携带数据吗？")]),t._v(" "),v("p",[t._v("其实第三次握手的时候，是可以携带数据的。但是，"),v("strong",[t._v("第一次、第二次握手不可以携带数据")])]),t._v(" "),v("p",[t._v("为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。")]),t._v(" "),v("p",[t._v("也就是说，"),v("strong",[t._v("第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。")])]),t._v(" "),v("p",{attrs:{id:"爱死外嗯攻击是什么"}}),t._v(" "),v("h2",{attrs:{id:"_60、syn攻击是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_60、syn攻击是什么"}},[t._v("#")]),t._v(" 60、SYN攻击是什么？")]),t._v(" "),v("p",[v("strong",[t._v("服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的")]),t._v("，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。")]),t._v(" "),v("p",[t._v("检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("netstat -n -p TCP | grep SYN_RECV\n复制代码\n")])])]),v("p",[t._v("常见的防御 SYN 攻击的方法有如下几种：")]),t._v(" "),v("ul",[v("li",[t._v("缩短超时（SYN Timeout）时间")]),t._v(" "),v("li",[t._v("增加最大半连接数")]),t._v(" "),v("li",[t._v("过滤网关防护")]),t._v(" "),v("li",[t._v("SYN cookies技术")])]),t._v(" "),v("p",{attrs:{id:"四次挥手相关内容"}})])}),[],!1,null,null,null);_.default=s.exports}}]);
